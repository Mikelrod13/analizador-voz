"""
API REST PARA SISTEMA DE ANÃLISIS EMOCIONAL
Servidor Flask que conecta el anÃ¡lisis de voz con la interfaz React
Autor: Miguel RodrÃ­guez LeÃ³n
"""

from flask import Flask, jsonify, request, send_from_directory
from flask_cors import CORS
from flask_socketio import SocketIO, emit
import threading
import time
import json
import os
from datetime import datetime
import logging
from collections import deque
import numpy as np

# Importar el analizador (asumiendo que estÃ¡ en el mismo directorio)
try:
    from voice_analyzer import EmotionalVoiceAnalyzer
except ImportError:
    print("âš ï¸ voice_analyzer.py no encontrado. Usando modo simulaciÃ³n.")
    EmotionalVoiceAnalyzer = None

# ConfiguraciÃ³n de Flask
app = Flask(__name__)
app.config['SECRET_KEY'] = 'cabinas-anti-suicidio-2025'
CORS(app, resources={r"/api/*": {"origins": "*"}})
socketio = SocketIO(app, cors_allowed_origins="*")

# ConfiguraciÃ³n de logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('cabin_system.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Variables globales
analyzer = None
current_session = None
is_analyzing = False
analysis_thread = None
session_history = deque(maxlen=100)

# Crear directorios necesarios
os.makedirs('data/sessions', exist_ok=True)
os.makedirs('data/incidents', exist_ok=True)
os.makedirs('logs', exist_ok=True)


class SessionManager:
    """Gestiona las sesiones de usuario en la cabina."""
    
    def __init__(self):
        self.session_id = None
        self.start_time = None
        self.states_history = []
        self.emergency_triggered = False
        self.chat_messages = []
    
    def start_session(self):
        """Inicia una nueva sesiÃ³n."""
        self.session_id = f"session_{int(time.time())}"
        self.start_time = datetime.now()
        self.states_history = []
        self.emergency_triggered = False
        self.chat_messages = []
        
        logger.info(f"âœ“ Nueva sesiÃ³n iniciada: {self.session_id}")
        return self.session_id
    
    def add_state(self, state_data):
        """Agrega un estado emocional al historial."""
        state_data['timestamp'] = datetime.now().isoformat()
        self.states_history.append(state_data)
        
        # Verificar si necesita intervenciÃ³n
        if state_data.get('risk_level') == 'critico':
            self.trigger_emergency(state_data)
    
    def trigger_emergency(self, state_data):
        """Activa el protocolo de emergencia."""
        if not self.emergency_triggered:
            self.emergency_triggered = True
            
            incident = {
                'incident_id': f"INC_{int(time.time())}",
                'session_id': self.session_id,
                'timestamp': datetime.now().isoformat(),
                'state_data': state_data,
                'action_taken': 'emergency_protocol_activated',
                'status': 'active'
            }
            
            # Guardar incidente
            incident_file = f"data/incidents/{incident['incident_id']}.json"
            with open(incident_file, 'w') as f:
                json.dump(incident, f, indent=2, ensure_ascii=False)
            
            logger.critical(f"ğŸš¨ EMERGENCIA ACTIVADA: {incident['incident_id']}")
            
            # Emitir evento a travÃ©s de WebSocket
            socketio.emit('emergency_alert', incident)
            
            return incident
    
    def add_chat_message(self, message_type, content):
        """Agrega un mensaje al chat."""
        message = {
            'type': message_type,
            'content': content,
            'timestamp': datetime.now().isoformat()
        }
        self.chat_messages.append(message)
        return message
    
    def end_session(self):
        """Finaliza la sesiÃ³n y guarda los datos."""
        if not self.session_id:
            return None
        
        end_time = datetime.now()
        duration = (end_time - self.start_time).total_seconds()
        
        session_data = {
            'session_id': self.session_id,
            'start_time': self.start_time.isoformat(),
            'end_time': end_time.isoformat(),
            'duration_seconds': duration,
            'states_count': len(self.states_history),
            'states_history': self.states_history,
            'emergency_triggered': self.emergency_triggered,
            'chat_messages': self.chat_messages,
            'summary': self._generate_summary()
        }
        
        # Guardar sesiÃ³n
        session_file = f"data/sessions/{self.session_id}.json"
        with open(session_file, 'w') as f:
            json.dump(session_data, f, indent=2, ensure_ascii=False)
        
        logger.info(f"âœ“ SesiÃ³n finalizada: {self.session_id} (duraciÃ³n: {duration:.0f}s)")
        
        # Limpiar
        self.session_id = None
        return session_data
    
    def _generate_summary(self):
        """Genera un resumen de la sesiÃ³n."""
        if not self.states_history:
            return {'status': 'no_data'}
        
        emotions = [s.get('emotion', 'neutral') for s in self.states_history]
        risks = [s.get('risk_level', 'normal') for s in self.states_history]
        
        from collections import Counter
        emotion_counts = Counter(emotions)
        risk_counts = Counter(risks)
        
        return {
            'dominant_emotion': emotion_counts.most_common(1)[0][0],
            'emotion_distribution': dict(emotion_counts),
            'max_risk_level': max(risks, key=lambda x: ['normal', 'medio', 'alto', 'critico'].index(x)),
            'risk_distribution': dict(risk_counts),
            'total_analyses': len(self.states_history)
        }


def continuous_analysis_loop():
    """Loop principal de anÃ¡lisis continuo."""
    global is_analyzing, current_session, analyzer
    
    logger.info("ğŸ¤ AnÃ¡lisis continuo iniciado")
    
    while is_analyzing:
        try:
            if analyzer and EmotionalVoiceAnalyzer:
                # AnÃ¡lisis real con micrÃ³fono
                audio = analyzer.record_audio_segment()
                features = analyzer.extract_features(audio)
                
                if features:
                    emotion, risk, confidence, explanation = analyzer.classify_emotion(features)
                    
                    state_data = {
                        'emotion': emotion,
                        'risk_level': risk,
                        'confidence': round(confidence, 2),
                        'explanation': explanation,
                        'features': {
                            'volume': round(features['volume_mean'], 3),
                            'pitch': round(features['pitch_mean'], 1),
                            'tempo': round(features['tempo'], 1),
                            'pause_duration': round(features['avg_pause_duration'], 2),
                            'speech_ratio': round(features['speech_ratio'], 2)
                        }
                    }
                else:
                    state_data = {'emotion': 'neutral', 'risk_level': 'normal', 'confidence': 0}
            else:
                # Modo simulaciÃ³n (para pruebas sin micrÃ³fono)
                emotions = ['neutral', 'estable', 'tristeza', 'ansiedad', 'depresion']
                risks = ['normal', 'normal', 'medio', 'medio', 'alto']
                idx = np.random.randint(0, len(emotions))
                
                state_data = {
                    'emotion': emotions[idx],
                    'risk_level': risks[idx],
                    'confidence': round(np.random.uniform(0.6, 0.95), 2),
                    'explanation': 'AnÃ¡lisis simulado (modo demo)',
                    'features': {
                        'volume': round(np.random.uniform(0.02, 0.15), 3),
                        'pitch': round(np.random.uniform(120, 280), 1),
                        'tempo': round(np.random.uniform(90, 180), 1),
                        'pause_duration': round(np.random.uniform(0.5, 2.5), 2),
                        'speech_ratio': round(np.random.uniform(0.4, 0.9), 2)
                    }
                }
            
            # Agregar a la sesiÃ³n actual
            if current_session:
                current_session.add_state(state_data)
            
            # Emitir actualizaciÃ³n por WebSocket
            socketio.emit('state_update', state_data)
            
            # Pausa entre anÃ¡lisis
            time.sleep(2)
            
        except Exception as e:
            logger.error(f"Error en anÃ¡lisis continuo: {e}")
            time.sleep(1)
    
    logger.info("ğŸ¤ AnÃ¡lisis continuo detenido")


# ============================================================================
# RUTAS DE LA API
# ============================================================================

@app.route('/')
def index():
    """PÃ¡gina de inicio."""
    return jsonify({
        'service': 'Cabinas Anti-suicidio - API',
        'version': '1.0',
        'status': 'online',
        'endpoints': {
            'session': '/api/session/*',
            'analysis': '/api/analysis/*',
            'emergency': '/api/emergency',
            'chat': '/api/chat',
            'stats': '/api/stats'
        }
    })


@app.route('/api/session/start', methods=['POST'])
def start_session():
    """Inicia una nueva sesiÃ³n."""
    global current_session, is_analyzing, analysis_thread, analyzer
    
    try:
        # Crear nueva sesiÃ³n
        current_session = SessionManager()
        session_id = current_session.start_session()
        
        # Inicializar analizador si existe
        if EmotionalVoiceAnalyzer and not analyzer:
            analyzer = EmotionalVoiceAnalyzer(duration=3)
        
        # Iniciar anÃ¡lisis continuo
        if not is_analyzing:
            is_analyzing = True
            analysis_thread = threading.Thread(target=continuous_analysis_loop)
            analysis_thread.daemon = True
            analysis_thread.start()
        
        return jsonify({
            'status': 'success',
            'session_id': session_id,
            'message': 'SesiÃ³n iniciada correctamente'
        })
        
    except Exception as e:
        logger.error(f"Error al iniciar sesiÃ³n: {e}")
        return jsonify({'status': 'error', 'message': str(e)}), 500


@app.route('/api/session/end', methods=['POST'])
def end_session():
    """Finaliza la sesiÃ³n actual."""
    global current_session, is_analyzing
    
    try:
        if not current_session:
            return jsonify({'status': 'error', 'message': 'No hay sesiÃ³n activa'}), 400
        
        # Detener anÃ¡lisis
        is_analyzing = False
        time.sleep(1)  # Esperar a que termine el loop
        
        # Guardar y finalizar sesiÃ³n
        session_data = current_session.end_session()
        current_session = None
        
        return jsonify({
            'status': 'success',
            'session_data': session_data,
            'message': 'SesiÃ³n finalizada correctamente'
        })
        
    except Exception as e:
        logger.error(f"Error al finalizar sesiÃ³n: {e}")
        return jsonify({'status': 'error', 'message': str(e)}), 500


@app.route('/api/analysis/state', methods=['GET'])
def get_current_state():
    """Obtiene el estado emocional actual."""
    if not current_session or not current_session.states_history:
        return jsonify({
            'emotion': 'neutral',
            'risk_level': 'normal',
            'confidence': 0,
            'message': 'Sin datos disponibles'
        })
    
    # Retornar el Ãºltimo estado
    latest_state = current_session.states_history[-1]
    return jsonify(latest_state)


@app.route('/api/analysis/history', methods=['GET'])
def get_analysis_history():
    """Obtiene el historial de anÃ¡lisis de la sesiÃ³n."""
    if not current_session:
        return jsonify({'status': 'error', 'message': 'No hay sesiÃ³n activa'}), 400
    
    return jsonify({
        'session_id': current_session.session_id,
        'states_count': len(current_session.states_history),
        'history': current_session.states_history[-20:]  # Ãšltimos 20
    })


@app.route('/api/emergency', methods=['POST'])
def trigger_emergency():
    """Activa el protocolo de emergencia manualmente."""
    if not current_session:
        return jsonify({'status': 'error', 'message': 'No hay sesiÃ³n activa'}), 400
    
    try:
        # Obtener Ãºltimo estado o crear uno de emergencia
        if current_session.states_history:
            last_state = current_session.states_history[-1]
        else:
            last_state = {
                'emotion': 'crisis',
                'risk_level': 'critico',
                'confidence': 1.0,
                'explanation': 'ActivaciÃ³n manual de emergencia'
            }
        
        incident = current_session.trigger_emergency(last_state)
        
        # AquÃ­ se integrarÃ­a con Twilio (siguiente paso)
        logger.critical(f"ğŸš¨ EMERGENCIA MANUAL: {incident['incident_id']}")
        
        return jsonify({
            'status': 'success',
            'incident': incident,
            'action': 'emergency_protocol_activated',
            'next_steps': [
                'Llamada a lÃ­nea de crisis iniciada',
                'Supervisor notificado',
                'UbicaciÃ³n compartida',
                'Registro de incidente creado'
            ]
        })
        
    except Exception as e:
        logger.error(f"Error al activar emergencia: {e}")
        return jsonify({'status': 'error', 'message': str(e)}), 500


@app.route('/api/chat', methods=['POST'])
def chat_message():
    """Procesa mensajes del chat."""
    if not current_session:
        return jsonify({'status': 'error', 'message': 'No hay sesiÃ³n activa'}), 400
    
    try:
        data = request.get_json()
        user_message = data.get('message', '')
        
        if not user_message:
            return jsonify({'status': 'error', 'message': 'Mensaje vacÃ­o'}), 400
        
        # Guardar mensaje del usuario
        current_session.add_chat_message('user', user_message)
        
        # Generar respuesta (aquÃ­ se integrarÃ­a Claude API - siguiente paso)
        # Por ahora, respuesta simple basada en estado emocional
        if current_session.states_history:
            emotion = current_session.states_history[-1].get('emotion', 'neutral')
        else:
            emotion = 'neutral'
        
        responses = {
            'ansiedad': 'Entiendo que te sientes ansioso. Tu respiraciÃ³n puede ayudarte. Â¿Quieres hacer un ejercicio de respiraciÃ³n?',
            'tristeza': 'EstÃ¡ bien sentirse triste. Tus emociones son vÃ¡lidas. Â¿Quieres hablar sobre lo que sientes?',
            'depresion': 'Entiendo que te sientes abrumado. No estÃ¡s solo. Â¿Hay algo especÃ­fico que te preocupa ahora?',
            'crisis': 'Escucho que estÃ¡s pasando por un momento muy difÃ­cil. Hay personas disponibles para ayudarte ahora mismo. Â¿Puedo conectarte con alguien?',
            'neutral': 'Te escucho. CuÃ©ntame mÃ¡s sobre eso.'
        }
        
        bot_response = responses.get(emotion, responses['neutral'])
        current_session.add_chat_message('bot', bot_response)
        
        return jsonify({
            'status': 'success',
            'response': bot_response,
            'emotion_detected': emotion
        })
        
    except Exception as e:
        logger.error(f"Error en chat: {e}")
        return jsonify({'status': 'error', 'message': str(e)}), 500


@app.route('/api/stats', methods=['GET'])
def get_statistics():
    """Obtiene estadÃ­sticas del sistema."""
    try:
        # Contar sesiones
        sessions_dir = 'data/sessions'
        incidents_dir = 'data/incidents'
        
        sessions = len([f for f in os.listdir(sessions_dir) if f.endswith('.json')]) if os.path.exists(sessions_dir) else 0
        incidents = len([f for f in os.listdir(incidents_dir) if f.endswith('.json')]) if os.path.exists(incidents_dir) else 0
        
        # Estado actual
        current_status = {
            'active_session': current_session.session_id if current_session else None,
            'analyzing': is_analyzing,
            'analyzer_available': EmotionalVoiceAnalyzer is not None
        }
        
        return jsonify({
            'total_sessions': sessions,
            'total_incidents': incidents,
            'current_status': current_status,
            'uptime': 'Sistema operativo'
        })
        
    except Exception as e:
        logger.error(f"Error al obtener estadÃ­sticas: {e}")
        return jsonify({'status': 'error', 'message': str(e)}), 500


# ============================================================================
# WEBSOCKET EVENTS (ComunicaciÃ³n en tiempo real)
# ============================================================================

@socketio.on('connect')
def handle_connect():
    """Cliente conectado."""
    logger.info(f"âœ“ Cliente conectado: {request.sid}")
    emit('connected', {'message': 'Conectado al servidor'})


@socketio.on('disconnect')
def handle_disconnect():
    """Cliente desconectado."""
    logger.info(f"âœ— Cliente desconectado: {request.sid}")


@socketio.on('request_state')
def handle_state_request():
    """Cliente solicita el estado actual."""
    if current_session and current_session.states_history:
        emit('state_update', current_session.states_history[-1])


# ============================================================================
# INICIO DEL SERVIDOR
# ============================================================================

if __name__ == '__main__':
    print("""
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘        API SERVIDOR - CABINAS ANTI-SUICIDIO              â•‘
    â•‘                                                          â•‘
    â•‘  Puerto: 5000                                            â•‘
    â•‘  WebSocket: Activado                                     â•‘
    â•‘  CORS: Habilitado                                        â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    """)
    
    logger.info("ğŸš€ Servidor iniciado en http://0.0.0.0:5000")
    
    # Iniciar servidor con WebSocket
    socketio.run(app, host='0.0.0.0', port=5000, debug=True, allow_unsafe_werkzeug=True)